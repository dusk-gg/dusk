---
title: ThreeJS Tech Demo
description: Building 3D games on Rune
slug: threejs
tags: [Game Development]
image: /img/blog/social-previews/threejs.png
authors:
- name: Kevin Glass 
  title: Founding Engineer at Rune  
  url: https://x.com/cokeandcode
  image_url: /img/blog/people/kevin-glass.jpg
  hide_table_of_contents: true
---

<head>
  <title>ThreeJS Tech Demo</title>
  <meta property="og:title" content="ThreeJS Tech Demo"/>
</head>

At Rune, we love all sorts of games from 2D, to isometric to 3D and we want you to use the tools you love on the platform. With 3D games comes the complexity of camera controls and character controllers can be tricky to feel right even in a single player game. The examples belows are aimed at providing a simple reference point for building 3D games with [ThreeJS](https://threejs.org) on the Rune. platform.

![](/img/blog/callouts/threejs.gif)

## Approach

Building a 3D game is a little more complicated than building a 2D game, through the multiplayer part is essentially the same in terms of Rune SDK usage. In this tech demo we'll cover the follow parts of building a multiplayer 3D game:

* Rendering / Shadows / Lighting
* Model Loading 
* Character and Camera Controller
* Input/Virtual Joystick
* Multiplayer Support with the Rune SDK

We'll be using the same approach we've used in previous tech demos where the controls the player inputs are whats provided between the client and logic. The logic will be responsible for all updates to the game world including collisions. Client side we'll make sure our 3D world matches the logic world and interpolate between positions and rotations so that everything feels smooth.

Using the wonderful at from [Kenney.nl](https://kenney.nl) we'll build a small scene in which the players can explore together.

## Rendering / Shadows / Lighting

**Setting Up the Renderer**

Below you can see the configuration for a reasonably nice but mobile friendly ThreeJS renderer. In particular we want the following configuration options if possible:

* Power Preference - indicates to the mobile device to get the best performance out of the graphics chip. This comes at the cost of battery life so if you can render less often then tune this down.
* Anti-aliasing - Player's really notice jagged lines in 3D rendering so if your end devices can support basic anti-aliasing its really worth the results.
* Tone Mapping - The depth of colors and shades of colors is changed by the tone mapping used. To my eye (ymmv) the `ACESFilmicToneMapping` gives the nicest thick colours effect.
* Shadows - Turn shadows on (this will have to be enabled in both meshes and lights separately). Shadows are something that really bring a scene to life but also an easy thing to turn off if your end devices aren't coping with the rendering.

```javascript
// the main ThreeJS scene we're rendering
const scene: Scene = new Scene()

// the Three JS renderer
const renderer = new WebGLRenderer({
  powerPreference: "high-performance",
  antialias: true,
})

// tone mapping controls how the color of points in the
// world is mapped to pixels on the screen. This tone mapping
// gives the rich look
renderer.toneMapping = ACESFilmicToneMapping

// enable the shadow map rendering
renderer.shadowMap.enabled = true
renderer.shadowMap.type = PCFShadowMap

// add the renderer to the DOM
renderer.setSize(window.innerWidth, window.innerHeight)
document.body.appendChild(renderer.domElement)

// background color with a fog to the distance
const skyBlue = 0x87ceeb
scene.background = new Color(skyBlue)
scene.fog = new FogExp2(skyBlue, 0.02)

// render the scene every at the configured FPS
setInterval(() => {
  render()
}, 1000 / RENDER_FPS)
```

We create and configure the renderer which create a DOM element (a canvas to be exact) which we can then add the document so the player can see it. We then configure a 
background for the scene so the sky is blue and theres a fog into the distance. Fog hides things that aren't rendered in the distance.

Finally we setup a rendering loop, in our case at 30 FPS. We could have of course used `requestAnimationFrame()` but since we want to render at less than the refresh of the
device (for low end device performance reasons) its easier to use a simple `setInterval`.

The render function is where all the updates across the game take place, it looks like this:

```javascript
// update the different elements of the game
updateInput()
const localPlayer = getLocalCharacter3D()
if (localPlayer) {
  getShadowingLightGroup().position.x = localPlayer.model.position.x
  getShadowingLightGroup().position.z = localPlayer.model.position.z

  updateCamera(localPlayer)
}
updateCharacterPerFrame(1 / RENDER_FPS)

// render the game with ThreeJS
renderer.render(scene, getCamera())
```

The updates of input, camera, lighting and character shown we be discussed later in this article.

**Enabled Lights and Shadows**

Along with the renderer we want to light the scene and render shadows. ThreeJS is super powerful in this regard with shadow mapping built right into the core
renderer. As you can see below for our tech demo we'll add two lights.

* Ambient Light - used to make everything visible in the scene but doesn't provide any shading
* Directional Light - used to light the models from a particular direction and hence provide shading. The directional light is also the source of shadows.

```javascript
// base ambient lighting so everything is visible
ambientLight = new AmbientLight(0xffffff, 1)
getScene().add(ambientLight)

// create the moveable directional light that generates
// the shadow map
lightGroup = new Object3D()
directionalLight = new DirectionalLight(0xffffff, 1)
directionalLight.position.set(-3, 3, 3)
lightGroup.add(directionalLight)
lightGroup.add(directionalLight.target)
getScene().add(lightGroup)

directionalLight.castShadow = true
directionalLight.shadow.mapSize.width = SHADOW_MAP_SIZE
directionalLight.shadow.mapSize.height = SHADOW_MAP_SIZE
directionalLight.shadow.camera.near = SHADOW_MAP_NEAR_PLANE
directionalLight.shadow.camera.far = SHADOW_MAP_FAR_PLANE
directionalLight.shadow.camera.left = -SHADOW_MAP_BOUNDS
directionalLight.shadow.camera.right = SHADOW_MAP_BOUNDS
directionalLight.shadow.camera.top = SHADOW_MAP_BOUNDS
directionalLight.shadow.camera.bottom = -SHADOW_MAP_BOUNDS
```

We've configure the frustrum (the viewpoint) of the shadow generator which describes how far the shadows will extend. Shadow mapping essentially re-renders the screen
from the perspective the light and generate a texture that can be applied to show shadows. This means it can be quite expensive and with a frustrum too large can result
in low resolution shadows. 

We also added the directional light to a group, so it can easily be moved along with the player. Why? The shadows are expensive to generate so we only want to render
shadows for the area local to the player (the bit they see). As the player moves around we'll see we also move that directional light with them, so shadows are always
rendered need to the player and no-where else.

## Model Loading

Model loading in ThreeJS couldn't be easier, and since Kenney provided his models in GLTF format we can simply used the loader built in to ThreeJS. 

```javascript
function loadGLTF(url: string): Promise<GLTF> {
  console.log("Loading: ", url)

  return new Promise<GLTF>((resolve, reject) => {
    gltfLoader.load(
      url,
      (model) => {
        // make every model loaded a shadow caster and receiver
        model.scene.traverse((child) => {
          child.castShadow = true
          child.receiveShadow = true
        })
        resolve(model)
      },
      undefined,
      (e) => {
        reject(e)
      }
    )
  })
}
```

Note that all the models we're loading we want to be cast shadow and receive them from other models so a quick `model.traverse()` to mark all the meshes appropriately. Now one
caveat is depending on how you load your models the ThreeJS loader might not be able to find any referenced textures. If thats the case for you, simply the load the textures
and apply them to the meshes.

```javascript
export function loadTexture(url: string): Promise<Texture> {
  return new Promise<Texture>((resolve, reject) => {
    textureLoader.load(
      url,
      (texture) => {
        texture.colorSpace = SRGBColorSpace
        resolve(texture)
      },
      undefined,
      (e) => {
        reject(e)
      }
    )
  })
}

export function applyTexture(obj: Object3D, texture: Texture) {
  obj.traverse((node) => {
    if (node instanceof Mesh) {
      node.material = new MeshLambertMaterial({ map: texture })
    }
  })
}
```

## Character and Camera Controller

One of the hard things to get right with 3D games is the character/camera controller. For our recent release, MeatSuits, we modelled and built a character
controller based on the ever popular Roblox. In this tech demo we've tried to distill that controller down into the cleanest code.

First lets setup a basic perspective camera and some controls to manage the view:

```javascript
// the position the camera is looking at - independent of the
// player position so we can move it smoothly
const lookAt: Vector3 = new Vector3(0, 1, 0)
// The angle we're trying to get to on the camera local Y axis. Independent
// of the actual value so it can be moved smoothly
let targetAngleY: number = 0
// The angle we're trying to get to on the cameral local Z axis. Independent
// of the actual value so it can be moved smoothly
let targetAngleZ: number = Math.PI

// The ThreeJS camera
const camera: PerspectiveCamera = new PerspectiveCamera(
  45,
  window.innerWidth / window.innerHeight,
  0.1,
  150
)
```

Next we have the per frame camera update. We'll interpolate the camera position and target location towards whatever has been configured in `lookAt`, `targetAngleY` and `targetAngleX`

```javascript
export function updateCamera(targetCharacter: Character3D) {
  // the offset from the ground the camera maintains
  const cameraHeight = 2
  // The distance from the target (look at)
  const cameraDistance = 4
  // The speed that the camera lerps at
  const cameraSoftness = 0.2
  // The height we're looking at - so we're not looking
  // at the player's feet
  const cameraTargetHeight = 1

  // work out where the camera "should be" once it's
  // finished smoothly moving
  const { x, y, z } = targetCharacter.model.position

  const targetPosition = new Vector3(cameraDistance, 0, 0)
  targetPosition.applyEuler(new Euler(0, -targetAngleY, -targetAngleZ))
  targetPosition.add(new Vector3(x, y + cameraHeight, z))

  // interpolate the camera's position to the place we want it to be
  camera.position.lerp(targetPosition, cameraSoftness)
  // interpolate the cameras's target to the player
  lookAt.lerp(new Vector3(x, y + cameraTargetHeight, z), cameraSoftness)
  camera.lookAt(lookAt)
}
```

Very simple right? The real trick with the Roblox style controller is that movement of the joystick is interpreted based on the camera's current viewpoint. So pushing up on the joystick
always goes into the view, pushing left always goes left in the camera's view. 

But wait, if that's the case then how do we ever turn a corner? As we'll see in the input section below theres a soft tweak to the rules applied on the client side.

## Input/Virtual Joystick

While when playing the demo you'd think there are only a couple of inputs there are actually quite a few parts that make the controller feel 'right'. First is the camera view adjustment - for the player this means being able to drag the view by using a second finger (i.e. not the joystick control). This for us is configured in the renderer code:

```javascript
renderer.domElement.addEventListener("touchstart", (e) => {
  mouseX = e.targetTouches[0].clientX
  mouseY = e.targetTouches[0].clientY
  mouseDown = true
})
renderer.domElement.addEventListener("touchend", () => {
  mouseDown = false
})
renderer.domElement.addEventListener("touchmove", (e) => {
  if (mouseDown) {
    const dx = e.targetTouches[0].clientX - mouseX
    const dy = e.targetTouches[0].clientY - mouseY
    mouseX = e.targetTouches[0].clientX
    mouseY = e.targetTouches[0].clientY

    rotateCameraZ(dy * 0.01)
    rotateCameraY(dx * 0.01)
  }
})
```

Pretty simple right? If we drag a finger on the background of the renderer then adjust the camera rotation.

Next we have the "real" input through the joystick and jump button, get the joystick state (and obey key pressed if testing on the web):

```javascript
const joystickState = getJoystickState()
const currentControls: Controls = {
  x: 0,
  y: 0,
  cameraAngle: getCameraAngle(),
  jump: isKeyDown(" ") || jump,
}

// generate controls to send to the server
if (isKeyDown("a") || joystickState.x < -DEAD_ZONE) {
  currentControls.x = isKeyDown("a") ? -1 : joystickState.x
}
if (isKeyDown("d") || joystickState.x > DEAD_ZONE) {
  currentControls.x = isKeyDown("d") ? 1 : joystickState.x
}
if (isKeyDown("w") || joystickState.y > DEAD_ZONE) {
  currentControls.y = isKeyDown("w") ? 1 : joystickState.y
}
if (isKeyDown("s") || joystickState.y < -DEAD_ZONE) {
  currentControls.y = isKeyDown("s") ? -1 : joystickState.y
}
```

Note that we're also recording the current `cameraAngle` as part of the controls. This is so the movement code in the logic (see below) knows how to interpret the inputs. 

Next we have the small tweak that allows us to turn corners. When moving left or right we move perpendicular to the camera angle, however we also gently turn the camera along with it:

```javascript
// if the controls indicate left/right motion then rotate the camera
// slightly to follow the turn
if (currentControls.x < 0) {
  rotateCameraY(-CAMERA_ROTATE * (Math.abs(currentControls.x) - DEAD_ZONE))
}
if (currentControls.x > 0) {
  rotateCameraY(CAMERA_ROTATE * (Math.abs(currentControls.x) - DEAD_ZONE))
}
```

This means if the player is running left/right the camera tries to turn to follow them. If they keep running left/right, since the direction of movement is relative to the camera angle, they'll end up running in a circle. 

Once we have the controls for this frame we need to consider updating the logic with them. Rune prevents the network getting flooding my allowing 10 updates per second, so we don't want to send too often or if the control input hasn't changed:

```javascript
// only send the control update if something has changed
if (
  lastSentControls.x !== currentControls.x ||
  lastSentControls.y !== currentControls.y ||
  lastSentControls.cameraAngle !== currentControls.cameraAngle ||
  lastSentControls.jump !== currentControls.jump
) {
  // only send the control update if we haven't sent one recent, or if:
  //
  // * We've stopped
  // * We've jumped
  //
  // Need to do those one's promptly to make it feel like the player
  // has direct control
  if (
    Date.now() - lastSentTime > CONTROLS_SEND_INTERVAL ||
    currentControls.jump || // send jump instantly
    (currentControls.x === 0 &&
      currentControls.y === 0 &&
      (lastSentControls.x !== 0 || lastSentControls.y !== 0))
  ) {
    Rune.actions.update(currentControls)
    lastSentControls = currentControls
    lastSentTime = Date.now()
    jump = false
  }
}
```

Note however if we stop moving or we jump we want to send that input as soon as possible - this is so the player feels more like they have direct control of their player. Any delay in stopping will have the player feeling "the lag".

Now we have input, models, a renderer, lighting and shadows! We just need to make the demo multiplayer.

## Multiplayer Support

Lets take a look at the client code first, as we've seen in previous tech demos theres a callback that Rune uses to tell us about game state updates `onChange`:

```javascript
Rune.initClient({
  onChange: ({ game, yourPlayerId }) => {
    // build the game map if we haven't already
    buildGameMap(game.map)

    for (const char of game.characters) {
      // theres a new character we haven't got in out scene
      if (!getCharacter3D(char.id)) {
        const char3D = createCharacter3D(char)
        if (char.id === yourPlayerId) {
          localPlayerCharacter = char3D
        }
      }

      // update the character based on the logic state
      updateCharacter3DFromLogic(char)
    }
    for (const id of getCurrentCharacterIds()) {
      // one of the scene characters has been removed
      if (!game.characters.find((c) => c.id === id)) {
        removeCharacter3D(id)
      }
    }
  },
})
```

That's all of our `onChange` code. We simply apply the follow code:

* Build the game map if we haven't already (see below)
* Make sure any characters the logic has told us about have a 3D model in our world
* Update any models in our world from the logic state
* Make sure any models that are in our world, that don't exist in the logic, are removed.

In the logic side we have a bit more to think about. Our game state is very light containing our player's input, the game world and the character running around in it:

```javascript
// the game state we store for the running game
export interface GameState {
  // the gamp map for collisions etc
  map: GameMap
  // the controls reported for each player
  controls: Record<PlayerId, Controls>
  // the characters in the game world
  characters: Character[]
}
```

When we startup we add a character to the world for any player:

```javascript
setup: (allPlayerIds) => {
  const state: GameState = {
    map: createGameMap(),
    controls: {},
    characters: [],
  }

  // create a character for each player
  for (const id of allPlayerIds) {
    addCharacter(id, state)
  }
  return state
},
```

Likewise when players join or leave we simply update the characters in the world:

```javascript
events: {
  playerLeft: (playerId, { game }) => {
    // remove the character that represents the player that left
    game.characters = game.characters.filter((c) => c.id !== playerId)
  },
  playerJoined: (playerId, { game }) => {
    // someone joined, add a new character for them
    addCharacter(playerId, game)
  },
},
```

In the logic's `update()` loop we move the characters around the world based on their inputs. The key part here is that the player's inputs are interpreted based on the angle of their camera:

```javascript
// if the player is trying to move then apply the movement assuming its not blocked
if (controls && (controls.x !== 0 || controls.y !== 0) && character) {
  // work out where the player would move to
  const newPos = getNewPositionAndAngle(controls, character.position)
  // check the height at that location
  const height = findHeightAt(game, newPos.pos.x, newPos.pos.z)
  const step = height - character.position.y
  // if we can step up the height or its beneath us then move the player
  if (step < MAX_STEP_UP) {
    // not blocked
    if (step > 0) {
      // stepping up
      character.position.y = height
    }
    character.position.x = newPos.pos.x
    character.position.z = newPos.pos.z
    // record the speed so the client side know hows quickly to interpolate
    character.lastMovementSpeed =
      Math.sqrt(controls.x * controls.x + controls.y * controls.y) *
      MOVE_SPEED
  }
  character.angle = newPos.angle
} else if (character) {
  character.lastMovementSpeed = 0
}
```

We'll look at the height of the map calculations below in the map section, the important part here is that `getNewPositionAndAngle()` function which takes the player's input and determines the new position and angle based on the same player's camera angle:

```javascript
export function getNewPositionAndAngle(
  controls: Controls,
  pos: Vec3
): { pos: Vec3; angle: number } {
  const dir = getDirectionFromAngle(controls.cameraAngle)
  const result = {
    pos: { ...pos },
    angle: 0,
  }
  result.angle = -(controls.cameraAngle - Math.atan2(-controls.x, controls.y))
  if (controls.x < 0) {
    result.pos.x += dir.z * MOVE_SPEED_PER_FRAME * Math.abs(controls.x)
    result.pos.z -= dir.x * MOVE_SPEED_PER_FRAME * Math.abs(controls.x)
  }
  if (controls.x > 0) {
    result.pos.x -= dir.z * MOVE_SPEED_PER_FRAME * Math.abs(controls.x)
    result.pos.z += dir.x * MOVE_SPEED_PER_FRAME * Math.abs(controls.x)
  }
  if (controls.y < 0) {
    result.pos.x -= dir.x * MOVE_SPEED_PER_FRAME * Math.abs(controls.y)
    result.pos.z -= dir.z * MOVE_SPEED_PER_FRAME * Math.abs(controls.y)
  }
  if (controls.y > 0) {
    result.pos.x += dir.x * MOVE_SPEED_PER_FRAME * Math.abs(controls.y)
    result.pos.z += dir.z * MOVE_SPEED_PER_FRAME * Math.abs(controls.y)
  }
  return result
}
```

This means that the player's controls are always relative to where their camera is looking, which leads to that Roblox like character controller we wanted.

## Rendering the Map

What would the world be without a map to explore? Our map in this tech demo is simple a grid of heights that generate blocks in the world for the player's to explore. Our game 
map definition is as follows:

```javascript
// wrapper for the content of each tile - useful
// if we want to add color or other attributes later
export type GameMapElement = number
// the actual game map is an array of tiles. We only
// specify the height if its non-zero to keep the size down
export type GameMap = GameMapElement[]
```

Since the map is just an array of 1x1 blocks determining the height at any given location becomes very performant: 

```javascript
export function getHeightAt(map: GameMap, x: number, z: number) {
  x = Math.floor(x)
  z = Math.floor(z)
  return map[x + z * GAME_MAP_WIDTH] ?? 0
}
```

This is useful since we're going to use a fairly brute force collision detection on the server. We work out the height at a player's position by sampling around
the player and picking the maximum. Each time the player attempts to move we calculate the height at the new location and compare it to the player's current height:

* If it's lower, then the player needs fall
* If its the same then nothing to change on the y-axis
* If its bigger but by a small amount the player should step up onto the block
* If its bigger byt by a large amount the player can't be moved to that location

You can see this code in logic's `update()` function calling our sampling function `findHeightAt` that looks like this:

```javascript
function findHeightAt(game: GameState, x: number, z: number) {
  let maxHeight = 0
  const characterSize = 0.5
  const step = characterSize / 5
  for (
    let xoffset = -characterSize / 2;
    xoffset <= characterSize / 2;
    xoffset += step
  ) {
    for (
      let zoffset = -characterSize / 2;
      zoffset <= characterSize / 2;
      zoffset += step
    ) {
      maxHeight = Math.max(
        maxHeight,
        getHeightAt(game.map, x + xoffset, z + zoffset)
      )
    }
  }

  return maxHeight
}
```

Finally we want to actually visualize the game map in the 3D world for our player's to explore. Since the game map is in the game state it's also available to the
client so at the start of the tech demo we do a `buildGameMap()`:

```javascript
export function buildGameMap(map: GameMap): void {
  // cycle through any blocks that are defined and create
  // a simple box with the wall texture at the right height
  for (let x = 0; x < GAME_MAP_WIDTH; x++) {
    for (let z = 0; z < GAME_MAP_HEIGHT; z++) {
      const height = getHeightAt(map, x, z)
      if (height) {
        const geometry = new BoxGeometry(1, 1, 1)
        const material = new MeshLambertMaterial({ map: wallTexture })
        const cube = new Mesh(geometry, material)
        cube.castShadow = true
        cube.receiveShadow = true
        cube.scale.y = height
        cube.position.x = x + 0.5
        cube.position.y = height / 2
        cube.position.z = z + 0.5
        getScene().add(cube)
      }
    }
  }
}
```

As you can see we cycle through the locations that have a height defined and create a textured box to represent that height. This leaves our player's with a bare
bones world to navigate.

With ThreeJS making a 3D game is an approachable task for any web developer. Making it multiplayer with the Rune SDK is also something that developers should find a straight forward task. Hopefully the code in this tech will cover the majority of cases where a game needs a nicely rendered 3D world and familiar controls as a base for something really wonderful! 

Look forward to seeing what 3D games you build on Rune next!

Want to know more? Why not drop by the [Discord](https://discord.gg/rune-devs) and have a chat?


